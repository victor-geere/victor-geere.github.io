<!doctype html>
<html>
<head>
    <title>Quaternions</title>
    <link rel="stylesheet" type="text/css" href="main.css">
    <script src="lib/math.min.js"></script>
    <script src="lib/dat.gui.min.js"></script>
</head>
<body>
<div id="floatingText"></div>

<script type="module">
    import * as THREE from './lib/three.module.js';
    import {colorsGrey, rainbow} from './modules/colors.js';
    import {
        getMaterial,
        drawAxis,
        makeSimpleCurve,
        buildScene,
        newVec,
        getPerspectiveCamera,
        getOrthoCamera
    } from './modules/threetools.js';
    import {
        roundTo, scaleVectors, subVectorsXY, addVectors,
        subVectors, moveVectors, addVectorArray, subtractVectorArray
    } from './modules/mathtools.js';

    let formula = '';
    let formulas = [];

    function setFormula(text, numerator, k, a, b) {
        if (formulas.length > 1) {
            formulas.splice(0, 1);
        }
        formulas.push(text);
        const title = `1/(n1...n2)^(a + bi)`;
        document.getElementById('floatingText').innerHTML = `${title}<br><span>${formulas[0]}</span> <br> <span>${formulas[1]}</span>`
    }

    function fn(r) {
        const n = roundTo(r, 3);
        const sign = n < 0 ? '-' : '+';
        const nAbs = Math.abs(n);
        if (nAbs === 0) {
            return '+ 0.000';
        }
        const nAbsStr = `${nAbs}0000000`.substr(0, 5);
        return `${sign} ${nAbsStr}`;
    }

    function getEta(numerator, k, a, b) {
        const baseFactor = gui.controllers.ctrlBaseFactor.getValue();
        const kx = k * baseFactor;
        const text = `${numerator}/(${kx}^(${a} + ${b}i))`;
        const result = math.evaluate(text);

        let formattedText = `${numerator}/(${roundTo(kx, 3)}^(${fn(a)} bi))`;
        setFormula(`${formattedText}`, numerator, k, a, b);

        return result;
    }

    function makeSphere() {
        const objTree = [];

        const meshMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            opacity: 0.05,
            transparent: true
        });

        const outlineMaterial = new THREE.LineBasicMaterial({
            color: 0x707080,
            opacity: 0.75,
            transparent: true
        });

        const outline2Material = new THREE.LineBasicMaterial({
            color: 0x707080,
            opacity: 0.75,
            transparent: true
        });

        let geometry = new THREE.SphereGeometry(1, 16, 16);
        // let material = new THREE.MeshBasicMaterial( getMaterial(rainbow, 20) );

        const sphereBack = new THREE.Mesh(geometry, meshMaterial);
        sphereBack.material.side = THREE.BackSide; // back faces
        sphereBack.renderOrder = 0;
        objTree.push(sphereBack);
        sceneInfo.group.add(sphereBack);

        const sphereFront = new THREE.Mesh(geometry, meshMaterial.clone());
        sphereFront.material.side = THREE.FrontSide; // front faces
        sphereFront.renderOrder = 1;
        objTree.push(sphereFront);
        sceneInfo.group.add(sphereFront);

        // new THREE.LineBasicMaterial( { color: 0xffffff } )
        const edges = new THREE.EdgesGeometry(geometry);
        const line = new THREE.LineSegments(edges, outlineMaterial);
        objTree.push(line);
        sceneInfo.group.add(line);

        const x = gui.controllers.ctrlX.getValue();
        const y = gui.controllers.ctrlY.getValue();
        const z = gui.controllers.ctrlZ.getValue();

        const lineY = gui.controllers.ctrlLatitude.getValue();
        const lineZ = gui.controllers.ctrlLongitude.getValue();
        const lineYC = math.sin(lineZ * math.pi / 180);
        let lineZC = -math.sin(lineY * math.pi / 180) * math.cos(lineZ * math.pi / 180);
        let lineXC = math.cos(lineY * math.pi / 180) * math.cos(lineZ * math.pi / 180);
        const points = [newVec(0, 0, 0), newVec(lineXC, lineYC, lineZC)];
        const guideLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), getMaterial(rainbow, 16));
        objTree.push(guideLine);
        sceneInfo.group.add(guideLine);

        const line2Y = gui.controllers.ctrlLatitude2.getValue();
        const line2Z = gui.controllers.ctrlLongitude2.getValue();
        const line2YC = math.sin(line2Z * math.pi / 180);
        let line2ZC = -math.sin(line2Y * math.pi / 180) * math.cos(line2Z * math.pi / 180);
        let line2XC = math.cos(line2Y * math.pi / 180) * math.cos(line2Z * math.pi / 180);
        const points2 = [newVec(0, 0, 0), newVec(line2XC, line2YC, line2ZC)];
        const guideLine2 = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points2), getMaterial(rainbow, 42));
        objTree.push(guideLine2);
        sceneInfo.group.add(guideLine2);

        const arc = drawArch({z: lineZ, y: lineY, p: points}, {z: line2Z, y: line2Y, p: points2});
        // const arc = drawArch(points[1], points2[1]);
        if (arc.length !== 0) {
            objTree.push(arc);
            sceneInfo.group.add(arc);
        }

        //
        // objTree.forEach((obj) => {
        //     obj.rotateX(x * math.pi / 180);
        //     obj.rotateY(y * math.pi / 180);
        //     obj.rotateZ(z * math.pi / 180);
        // });

        return objTree;
    }

    function getPoints(p1, p2) {
        const yDiff = p1.y;
        for (let i = 0; i < 64; i++) {
        }

        return points;
    }

    function drawArch(p1, p2) {
        if (p1.z === p2.z) {
            return [];
        }
        let a1 = p1.z;
        let a2 = p2.z;
        if (p1.z > p2.z) {
            a1 = p2.z;
            a2 = p1.z;
        }

        // console.log(`${point1.x} ${point1.y} - ${point2.x} ${point2.y}`)
        const curve = new THREE.EllipseCurve(
            0, 0,                                       // ax, aY
            1, 1,                                       // xRadius, yRadius
            0, (360 - (a1 - a2)) * Math.PI / 180,       // aStartAngle, aEndAngle
            false,                                      // aClockwise
            a1 * Math.PI / 180                        // aRotation
        );

        const points = curve.getPoints( 64 ); //getPoints(p1, p2);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);

        const material = new THREE.LineBasicMaterial({color: 0xffff00});

// Create the final object to add to the scene
        const ellipse = new THREE.Line(geometry, material);
        return ellipse;
    }

    function drawArches() {
        sceneInfo.clear();
        const tree = makeSphere();
    }

    function onResize() {
        drawChoice();
    }

    /**
     * animate objects per frame
     */
    function updateObjects() {
        if (sceneInfo.hasChanged) {
            sceneInfo.scale(gui.controllers.ctrlScale.getValue());
            sceneInfo.hasChanged = false;
        }
    }

    function animationLoop() {
        sceneInfo.animationLoopId = requestAnimationFrame(animationLoop);
        updateObjects();
        sceneInfo.render();
    }

    function hasChanged() {
        sceneInfo.hasChanged = true;
    }

    function popGui(gui) {
        gui.options.load = gui.parameters;
        const datGui = new dat.GUI(gui.options);
        gui.controllers.ctrlScale = datGui.add(gui.parameters, 'Scale', 0, 10, 0.05).onChange(hasChanged);

        gui.controllers.ctrlX = datGui.add(gui.parameters, 'X', 0, 360, 1).onChange(drawChoice);
        gui.controllers.ctrlY = datGui.add(gui.parameters, 'Y', 0, 360, 1).onChange(drawChoice);
        gui.controllers.ctrlZ = datGui.add(gui.parameters, 'Z', 0, 360, 1).onChange(drawChoice);

        gui.controllers.ctrlLatitude = datGui.add(gui.parameters, 'Latitude1', 0, 360, 1).onChange(drawChoice);
        gui.controllers.ctrlLongitude = datGui.add(gui.parameters, 'Longitude1', 0, 360, 1).onChange(drawChoice);

        gui.controllers.ctrlLatitude2 = datGui.add(gui.parameters, 'Latitude2', 0, 360, 1).onChange(drawChoice);
        gui.controllers.ctrlLongitude2 = datGui.add(gui.parameters, 'Longitude2', 0, 360, 1).onChange(drawChoice);
    }

    const gui = {
        options: {name: 'Parameter GUI', autoPlace: true, hideable: true, closed: false, closeOnTop: false},
        controllers: {
            ctrlScale: null,
            ctrlX: null,
            ctrlY: null,
            ctrlZ: null,
            ctrlLongitude1: null,
            ctrlLatitude1: null,
            ctrlLongitude2: null,
            ctrlLatitude2: null,
        },
        parameters: {
            'Scale': 5,
            'X': 0,
            'Y': 0,
            'Z': 0,
            'Latitude1': 0,
            'Longitude1': 0,
            'Latitude2': 0,
            'Longitude2': 13,
        }
    };

    function drawChoice() {
        switch (type) {
            case CIRCLES:
                break;
            case ARCHES:
                drawArches();
                break;
        }
    }

    const CIRCLES = 1;
    const ARCHES = 2;
    let type = ARCHES;

    const camera = getOrthoCamera(window.innerWidth / 25, window.innerHeight / 25);
    let sceneInfo = buildScene(document.body, window.innerWidth, window.innerHeight, 3, 0x303035, 0xffffff, camera);
    window.addEventListener("resize", onResize);
    popGui(gui);
    drawAxis(sceneInfo.scene, 40);
    drawChoice();
    sceneInfo.scale(gui.controllers.ctrlScale.getValue());
    animationLoop();

</script>

</body>
</html>
