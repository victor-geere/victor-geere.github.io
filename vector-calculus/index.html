<html>
<title>Helix</title>
<head>
<!--    https://stackoverflow.com/questions/50992863/creating-a-helix-following-a-curve-->
    <style href="main.css"></style>
    <script src="lib/math.min.js"></script>
    <script src="lib/dat.gui.min.js"></script>
</head>
<body>
<script type="module">
    import * as THREE from './lib/three.module.js';
    import { OrbitControls } from './lib/OrbitControls.js';
    import { colorsA } from './colors.js';
    import { Z } from  './zeta.js';

    function resize() {
        WIDTH = window.innerWidth;
        HEIGHT = window.innerHeight;
        renderer.setSize(WIDTH, HEIGHT);
        camera.aspect = aspectRatio();
        camera.updateProjectionMatrix();
    }

    function getSmoothPointsSpiral(a, b) {
        let curvePointsObj = { sum:[] };
        var k = 1;
        var s;
        var vector, vectorSum;
        var z = 0;
        var sumRe = 0;
        var sumIm = 0;

        while(k < 2000) {
            s = math.evaluate(`1/(${k}^(${a} + ${b}i))`);
            vector = new THREE.Vector3(s.re, s.im, z / 10);

            z += 1 / k;

            if (k % 2 === 1) {
                sumRe = sumRe + s.re;
                sumIm = sumIm + s.im;
            } else if (k % 2 === 0) {
                sumRe = sumRe - s.re;
                sumIm = sumIm - s.im;
            }
            vectorSum = new THREE.Vector3(sumRe, sumIm, z / 10);
            curvePointsObj.sum.push(vectorSum);

            if (k === 3) {
                metaPlots.degree1.points.im = sumIm;
                metaPlots.degree1.points.re = sumRe;
                metaPlots.degree1.points.z = z/10;
            }

            k = k + 1;
        }
        metaPlots.convergence.points.im = sumIm;
        metaPlots.convergence.points.re = sumRe;
        metaPlots.convergence.points.z = z/10;
        return curvePointsObj;
    }

    // prepare the renderer

    let WIDTH;
    let HEIGHT;
    let aspectRatio = function() {
        return WIDTH / HEIGHT
    };

    const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
    });
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(32, aspectRatio(), 1, 1000);
    camera.position.set(0, 0, 50);

    resize();

    window.addEventListener("resize", resize);

    const scene = new THREE.Scene();

    // xyz thingy
    scene.add( new THREE.AxesHelper( 40 ) );

    const light = new THREE.DirectionalLight(0xffffff, 1, Infinity);
    light.position.set(0, 0, 0);
    camera.add(light);
    scene.add(camera);

    // controls
    var controls = new OrbitControls( camera, renderer.domElement );
    controls.minDistance = 20;
    controls.maxDistance = 50;
    controls.maxPolarAngle = Math.PI / 2;

    // populate the scene

    let group = new THREE.Group();
    group.scale.set(3, 3, 3);
    scene.add(group);

    function getSpiral(curvePoints) {
        const obj = {};
        try {
            obj.curvePoints = curvePoints;
            obj.curve = new THREE.CatmullRomCurve3(obj.curvePoints);
            if (curvePoints.length > 1) {
                obj.geoPoints = obj.curve.getPoints(obj.curvePoints.length - 1);
                obj.geo = new THREE.BufferGeometry().setFromPoints(obj.geoPoints);
            }
        } catch (error) {
            console.log(`error ${error} curvePoints length: ${obj.curvePoints.length}`);
        }
        return obj;
    }

    let errorCount = 0;
    function addSpiral(curvePoints, material) {
        if (material) {
            const obj = getSpiral(curvePoints);
            obj.mat = material;
            obj.mesh = new THREE.Line(obj.geo, obj.mat);
            return obj;
        } else {
            if (errorCount++ < 2) {
                console.log('color undefined', {curvePoints, group, color});
            }
        }
        return null;
    }

    function getMaterial(colorN) {
        return new THREE.LineBasicMaterial({
            color: colorsA[colorN]
        })
    }

    function makeSpiral(a, b, materialN = 29) {
        let curvePoints = getSmoothPointsSpiral(a, b);
        return { sum: addSpiral(curvePoints.sum, getMaterial(materialN)) };
    }

    function addSpiralObjsToGroup(spiralObjs) {
        if (!sumDrawn && gui.controllers.ctrlDrawSum.getValue()) {
            sumDrawn = true;
            group.add(spiralObjs.sum.mesh);
        }
    }

    function drawOneSpiral() {
        let a = gui.controllers.ctrlRe.getValue();
        let b = gui.controllers.ctrlIm.getValue();
        let spiralObjs = makeSpiral(a, b, 20);
        addSpiralObjsToGroup(spiralObjs);
        return spiralObjs;
    }

    /**
     * animate objects per frame
     */
    function updateObjects() {
        if (hasChanged) {
            let a = gui.controllers.ctrlRe.getValue();
            let b = gui.controllers.ctrlIm.getValue();
            let curvePoints = getSmoothPointsSpiral(a, b);

            let spiralObjsTarget = {
                sum: getSpiral(curvePoints.sum)
            };
            if (gui.controllers.ctrlDrawSum.getValue()) {
                if(!sumDrawn) {
                    group.add(spiralObjsTarget.sum.mesh);
                }
                spiralObjects.sum.geo.setFromPoints(spiralObjsTarget.sum.geoPoints);
            } else {
                spiralObjects.sum.geo.setFromPoints([]);
            }

            renderer.render( scene, camera );
            if(gui.controllers.ctrlLoopRe.getValue()) {
                doLoopRe();
            } else if (gui.controllers.ctrlLoopIm.getValue()) {
                doLoopIm();
            } else {
                hasChanged = false;
            }
        }
    }

    function render() {
        renderer.render(scene, camera);
    }

    let animationLoopId = null;

    function animationLoop() {
        animationLoopId = requestAnimationFrame(animationLoop);
        updateObjects();
        render();
    }

    let loopReSign = 1;
    function doLoopRe() {
        let reLoopA = gui.controllers.ctrlRe.getValue();
        if(gui.controllers.ctrlLoopRe.getValue()) {
            reLoopA = reLoopA + (loopReSign * 0.0125);
            gui.controllers.ctrlRe.setValue(reLoopA);
            if (reLoopA <= 0) {
                loopReSign = 1;
                reLoopA = 0;
                gui.controllers.ctrlRe.setValue(reLoopA);
            } else if (reLoopA >= 1) {
                loopReSign = -1;
                reLoopA = 1;
                gui.controllers.ctrlRe.setValue(reLoopA);
            }
            hasChanged = true;
            if ((reLoopA * 10) % 1 === 0) {
                gui.controllers.ctrlRe.setValue(reLoopA);
            }
        } else {
            hasChanged = false;
        }
    }

    function recalc(plotName) {
        const plot = metaPlots[plotName];
        const plotPoints = plot.plotPath.length;
        const points = addSpiral(plot.plotPath, plot.material).geoPoints;
        let n = 0;
        let sortedPoints = [];
        if (Array.isArray(points)) {
            sortedPoints = points.map((point) => {
                return {x: point.x, y: point.y, z: ((plotPoints - n++) * 5 / plotPoints) + 1.6};
            });
        }
        if (plot.plotObjs && plot.plotObjs.geo && plot.plotObjs.geo.setFromPoints) {
            plot.plotObjs.geo.setFromPoints(sortedPoints);
        }
    }

    function buildPlotPath(plotName, allowedLength) {
        const plot = metaPlots[plotName];
        plot.plotPath.push(
            new THREE.Vector3(plot.points.re, plot.points.im, plot.plotPath.length / plot.totalPoints)
        );
        const tooLong = plot.plotPath.length - allowedLength;
        if (tooLong > 10) {
            plot.plotPath.splice(0, tooLong - 10);
        }

        if (plot.drawn) {
            plot.plotObjs.geo.dispose();
            recalc(plotName);
        } else {
            if(plot.plotPath.length > 2) {
                plot.plotObjs = addSpiral(plot.plotPath, plot.material);
                recalc(plotName);
                group.add(plot.plotObjs.mesh);
                plot.drawn = true;
            }
        }
    }

    /**
     * Exponentially shrink ping-pong plot as start and end is reached to make ping pong smooth
     */
    function getAllowedLength(maxN, n) {
        const midPoint = Math.floor(maxN/2);
        return Math.pow((midPoint - 1) - Math.abs(midPoint - n), 2);
    }

    let loopImSign = 1;
    function doLoopIm() {
        let imLoopB = gui.controllers.ctrlIm.getValue();
        let maxImLoopB = 100;
        const allowedLength = getAllowedLength(maxImLoopB, imLoopB);

        if (gui.controllers.ctrlDrawImLoop.getValue()) {
            buildPlotPath('convergence', allowedLength);
        } else {
            metaPlots.convergence.plotPath = [];
            recalc('convergence');
        }
        if (gui.controllers.ctrlDrawElbow.getValue()) {
            buildPlotPath('degree1', allowedLength);
        } else {
            metaPlots.degree1.plotPath = [];
            recalc('degree1');
        }

        if(gui.controllers.ctrlLoopIm.getValue()) {
            imLoopB = imLoopB + (loopImSign * (0.005 * gui.controllers.ctrlLoopImSpeed.getValue()));
            gui.controllers.ctrlIm.setValue(imLoopB);
            if (imLoopB <= 0) {
                loopImSign = 1;
                imLoopB = 0;
                gui.controllers.ctrlIm.setValue(imLoopB);
            } else if (imLoopB >= maxImLoopB) {
                loopImSign = -1;
                imLoopB = maxImLoopB;
                gui.controllers.ctrlIm.setValue(imLoopB);
            }
            hasChanged = true;
            if ((imLoopB * 10) % 1 === 0) {
                gui.controllers.ctrlIm.setValue(imLoopB);
            }
        } else {
            metaPlots.convergence.plotPath = [];
            hasChanged = false;
        }
    }

    function makeMetaPlot(material, totalPoints) {
        return {
            plotObjs: {
                curvePoints: [],
                curve: null,
                geoPoints: [],
                geo: [],
                mat: null,
                mesh: null
            },
            material,
            totalPoints,
            drawn: false,
            plotPath: [],
            points: {
                z: 0,
                re: 0,
                im: 0
            }
        }
    }

    function popGui(gui) {
        gui.options.load = gui.parameters;
        const datGui = new dat.GUI(gui.options);
        gui.controllers.ctrlLoopRe = datGui.add(gui.parameters, 'Loop Re', false, true).onFinishChange(() => {
            doLoopRe();
        });
        gui.controllers.ctrlLoopIm = datGui.add(gui.parameters, 'Loop Im', false, true).onFinishChange(() => {
            if (gui.parameters['Loop Im']) {
                doLoopIm();
            } else {
                hasChanged = false;
            }
        });
        gui.controllers.ctrlLoopImSpeed = datGui.add(gui.parameters, 'Loop Im Speed', 0, 40).onFinishChange(() => {
        });
        gui.controllers.ctrlScale = datGui.add(gui.parameters, 'Scale', 0, 10, 0.1).onChange(() => {
            group.scale.set(gui.parameters['Scale'], gui.parameters['Scale'], gui.parameters['Scale']);
            hasChanged = true;
        });
        gui.controllers.ctrlRe = datGui.add(gui.parameters, 'Real Part', 0.0, 1.0).onChange(() => {
            hasChanged = true;
        });
        gui.controllers.ctrlIm = datGui.add(gui.parameters, 'Imaginary Part', 0.000, 199.9999, 0.0001).onChange(() => {
            hasChanged = true;
        });
        gui.controllers.ctrlZero = datGui.add(gui.parameters, 'Riemann Zero #', 0, 28, 1).onFinishChange(() => {
            gui.controllers.ctrlRe.setValue(0.5);
            console.log('gui.parameters[\'Riemann Z Zero #\']', gui.parameters['Riemann Zero #']);
            gui.controllers.ctrlIm.setValue(Z[gui.parameters['Riemann Zero #']]);
            hasChanged = true;
        });
        gui.controllers.ctrlDrawSum = datGui.add(gui.parameters, 'Draw Sum', false, true).onFinishChange(() => {
            hasChanged = true;
        });
        gui.controllers.ctrlDrawImLoop = datGui.add(gui.parameters, 'Draw Im Loop', false, true);
        gui.controllers.ctrlDrawElbow = datGui.add(gui.parameters, 'Draw Elbow', false, true);
    }

    const gui = {
        options: { name: 'My GUI', autoPlace: true, hideable: true, closed: false, closeOnTop: true },
        controllers : {
            ctrlLoopImSpeed: null,
            ctrlLoopRe: null,
            ctrlLoopIm: null,
            ctrlScale: null,
            ctrlRe: null,
            ctrlIm: null,
            ctrlZero: null,
            ctrlSmoothing: null,
            ctrlDrawSum: null,
            ctrlDrawImLoop: null,
            ctrlDrawElbow: null,
        },
        parameters : {
            'Scale': 3,
            'Real Part': 0.5,
            'Imaginary Part': Z[0],
            'Riemann Zero #': 0,
            'Draw Sum': true,
            'Loop Re': false,
            'Loop Im': true,
            'Loop Im Speed': 20,
            'Draw Im Loop': true,
            'Draw Elbow': false
        }
    };
    popGui(gui);

    let hasChanged = false;
    let sumDrawn = false;
    let metaPlots = {
        convergence : makeMetaPlot(getMaterial(29), 250),
        degree1 : makeMetaPlot(getMaterial(1), 250)
    };

    let spiralObjects = drawOneSpiral(group);
    animationLoop();
    doLoopIm();
</script>

</body>
</html>
