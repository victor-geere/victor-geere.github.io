<html>
<title>Helix</title>
<head>
<!--    https://stackoverflow.com/questions/50992863/creating-a-helix-following-a-curve-->
    <style href="main.css"></style>
<!--    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/93/three.js"></script>-->
    <script src="lib/math.min.js"></script>
    <script src="node_modules/dat.gui/build/dat.gui.min.js"></script>
</head>
<body>
<script type="module">
    import * as THREE from './node_modules/three/build/three.module.js';

    import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';
    // import { ConvexBufferGeometry } from './node_modules/three/examples/jsm/geometries/ConvexGeometry.js';

    const Z = [
        14.134725142,
        21.022039639,
        25.010857580,
        30.424876126,
        32.935061588,
        37.586178159,
        40.918719012,
        43.327073281,
        48.005150881,
        49.773832478,
        52.970321478,
        56.446247697,
        59.347044003,
        60.831778525,
        65.112544048,
        67.079810529,
        69.546401711,
        72.067157674,
        75.704690699,
        77.144840069,
        79.337375020,
        82.910380854,
        84.735492981,
        87.425274613,
        88.809111208,
        92.491899271,
        94.651344041,
        95.870634228,
        98.831194218,
        101.317851006,
        103.725538040,
        105.446623052,
        107.168611184,
        111.029535543,
        111.874659177,
        114.320220915,
        116.226680321,
        118.790782866,
        121.370125002,
        122.946829294
    ];
    function resize() {
        WIDTH = window.innerWidth;
        HEIGHT = window.innerHeight;
        renderer.setSize(WIDTH, HEIGHT);
        camera.aspect = aspectRatio();
        camera.updateProjectionMatrix();
    }

    function norm(r) {
        return r * 2;
    }

    function getSmoothPointsSpiral(a, b) {
        let curvePointsObj = { even: [], odd: [], sum:[] };
        var k = 1;
        var s;
        var vector, vectorSum;
        var z = 0;
        var sumRe = 0;
        var sumIm = 0;

        while(k < 1000) {
            s = math.evaluate(`1/(${k}^(${a} + ${b}i))`);
            vector = new THREE.Vector3(norm(z / 10), norm(s.re), norm(s.im));

            z += 1 / k;

            if (k % 2 === 1) {
                sumRe = sumRe + s.re;
                sumIm = sumIm + s.im;
                curvePointsObj.odd.push(vector);
            } else if (k % 2 === 0) {
                sumRe = sumRe - s.re;
                sumIm = sumIm - s.im;
                curvePointsObj.even.push(vector);
            }
            vectorSum = new THREE.Vector3(norm(z / 10), sumRe, sumIm);
            curvePointsObj.sum.push(vectorSum);
            k = k + 1;
        }
        convergence.im = sumIm;
        convergence.re = sumRe;
        convergence.z = norm(z/10);
        return curvePointsObj;
    }

    function getPointsSpiral(a, b) {
        let curvePointsObj = { even: [], odd: [], sum:[] };
        var k = 1;
        var s;
        var vector, vectorSum;
        var angle = 0;
        var radius2 = 0;
        var z = 0;
        var cos = 0;
        var sign = (k % 2 === 1)? 1 : -1;
        var sumRe = 0;
        var sumIm = 0;
        var pn = 0;

        while(k < 400) {
            s = math.evaluate(`1/(${k}^(${a} + ${b}i))`);
            radius2 = (s.re * s.re + s.im * s.im);
            angle = math.evaluate(`asin(sqrt(${radius2}))*180/pi`);
            cos = math.evaluate(`cos(${angle} * pi / 180)`);
            // console.log(`angle ${angle} : cos ${cos}`);
            z += 2 / k;

            sumRe += (sign * s.re);
            sumIm += (sign * s.im);

            if (k > 20) {
                vector = new THREE.Vector3(norm(z / 10), norm(sign * s.re), norm(sign * s.im));
                vectorSum = new THREE.Vector3(norm(z / 10), norm(sumRe), norm(sumIm));
                curvePointsObj.sum.push(vectorSum);

                if (k % 2 === 1) {
                    curvePointsObj.odd.push(vector);
                } else if (k % 2 === 0) {
                    curvePointsObj.even.push(vector);
                }
            }
            k = k + 1;
            sign = (k % 2 === 1)? 1 : -1;
        }
        return curvePointsObj;
    }

    /**
     * just an example helix
     *
     * @returns {[]}
     */
    function getPoints() {
        let curvePoints = [];
        let rad = Math.PI / 4;
        for (let i = -10; i <= 10; ++i) {
            curvePoints.push(new THREE.Vector3(i / 5, Math.sin(rad * i), Math.cos(rad * i)));
        }
        return curvePoints;
    }

    // prepare the renderer

    let WIDTH;
    let HEIGHT;
    let aspectRatio = function() {
        return WIDTH / HEIGHT
    };

    const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
    });
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(32, aspectRatio(), 1, 1000);
    camera.position.set(0, 0, 50);

    resize();

    window.addEventListener("resize", resize);

    const scene = new THREE.Scene();

    // helper
    scene.add( new THREE.AxesHelper( 40 ) );

    const light = new THREE.DirectionalLight(0xffffff, 1, Infinity);
    light.position.set(0, 0, 0);
    camera.add(light);
    scene.add(camera);

    // controls
    var controls = new OrbitControls( camera, renderer.domElement );
    controls.minDistance = 20;
    controls.maxDistance = 50;
    controls.maxPolarAngle = Math.PI / 2;

    // populate the scene

    let group = new THREE.Group();
    group.scale.set(5, 5, 5);
    scene.add(group);

    function getSpiral(curvePoints) {
        const obj = {};
        obj.curvePoints = curvePoints;
        obj.curve = new THREE.CatmullRomCurve3(obj.curvePoints);
        obj.geoPoints = obj.curve.getPoints((obj.curvePoints.length-1) * parameters["Smoothing Factor"]);
        obj.geo = new THREE.BufferGeometry().setFromPoints(obj.geoPoints);
        return obj;
    }

    let errorCount = 0;
    function addSpiral(curvePoints, material) {
        if (material) {
            const obj = getSpiral(curvePoints);
            obj.mat = material;
            obj.mesh = new THREE.Line(obj.geo, obj.mat);
            return obj;
        } else {
            if (errorCount++ < 2) {
                console.log('color undefined', {curvePoints, group, color});
            }
        }
        return null;
    }

    function getMaterial(colorN) {
        return new THREE.LineBasicMaterial({
            color: colorsA[colorN]
        })
    }

    function makeSpiral(a, b, materials = null) {
        if (!materials) {
            materials = [getMaterial(0), getMaterial(10), getMaterial(29)];
        }
        let curvePoints = getSmoothPointsSpiral(a, b);
        let spiralObjs = { odd: {}, even: {}, sum: {}, convergence: {} };
        spiralObjs.even = addSpiral(curvePoints.even, materials[0]);
        spiralObjs.odd = addSpiral(curvePoints.odd, materials[1]);
        spiralObjs.sum = addSpiral(curvePoints.sum, materials[2]);
        console.log('spiralObjs', spiralObjs);
        return spiralObjs;
    }

    const colorsA = [
        "#10f080",
        "#20e080",
        "#30d080",
        "#40c080",
        "#50b080",
        "#60a080",
        "#709080",
        "#808080",
        "#907080",
        "#a06080",
        "#b05080",
        "#c04080",
        "#d03080",
        "#e02080",
        "#f01080",
        "#e01070",
        "#d01060",
        "#c01050",
        "#b01040",
        "#a01030",
        "#901020",
        "#801010",
        "#701020",
        "#601030",
        "#501040",
        "#401050",
        "#301060",
        "#201070",
        "#101080",
        "#101090",
    ];

    function addSpiralObjsToGroup(spiralObjs) {
        group.add(spiralObjs.even.mesh);
        group.add(spiralObjs.odd.mesh);
        if (!sumDrawn && parameters['Draw Sum']) {
            sumDrawn = true;
            group.add(spiralObjs.sum.mesh);
        }
    }

    function drawOneSpiral() {
        let a = parameters["Real Part"];
        let b = parameters["Imaginary Part"];
        let spiralObjs = makeSpiral(a, b);
        addSpiralObjsToGroup(spiralObjs);
        return spiralObjs;
    }

    function loopRealPart(group) {
        let a = 0.325;
        let colorIx = 0;
        let sums = [];
        let sumVector;
        let spirals = 0;
        let material = null;
        while (colorIx < colorsA.length) {
            material = getMaterial(colorIx);
            let spiralObjs = makeSpiral(a, Z[0], [material, material, material]);
            addSpiralObjsToGroup(spiralObjs, group);
            sums.push(spiralObjs.sum.curvePoints[spiralObjs.sum.curvePoints.length-1]);
            a = a + 0.025;
            colorIx++;
            spirals++;
        }
        console.log('checking: ', { spirals, colorIx, nColors: colorsA.length } );
        // draw a line that connects the convergence points of the above graphs
        group.add(addSpiral(sums, getMaterial(30)).mesh);
    }

    function loopImaginaryPart() {
        let a = 0.5;
        let b = 10;
        var colorIx = 0;
        var sums = [];
        var sumVector;
        while (b < 15) {
            sumVector = makeSpiral(group, a, b, [colorsA[colorIx*2], colorsA[colorIx*2], colorsA[colorIx*2]]);
            sums.push(sumVector);
            b++;
            colorIx++;
        }
    }
    // loopImaginaryPart();

    /**
     * animate objects per frame
     */
    function updateObjects() {
        if (hasChanged) {
            let a = parameters['Real Part'];
            let b = parameters['Imaginary Part'];
            let curvePoints = getSmoothPointsSpiral(a, b);

            let spiralObjsTarget = {
                even: getSpiral(curvePoints.even),
                odd: getSpiral(curvePoints.odd),
                sum: getSpiral(curvePoints.sum)
            };
            spiralObjects.even.geo.dispose();
            spiralObjects.even.geo.setFromPoints(spiralObjsTarget.even.geoPoints);
            spiralObjects.odd.geo.dispose();
            spiralObjects.odd.geo.setFromPoints(spiralObjsTarget.odd.geoPoints);
            if (parameters['Draw Sum']) {
                if(!sumDrawn) {
                    group.add(spiralObjsTarget.sum.mesh);
                }
                spiralObjects.sum.geo.setFromPoints(spiralObjsTarget.sum.geoPoints);
            } else {
                spiralObjects.sum.geo.setFromPoints([]);
            }

            renderer.render( scene, camera );
            if(parameters['Loop Re']) {
                doLoopRe();
            } else if (parameters['Loop Im']) {
                doLoopIm();
            } else {
                hasChanged = false;
            }
        }
    }

    // rendering functions

    function render() {
        renderer.render(scene, camera);
    }

    let animationLoopId = null;

    function animationLoop() {
        animationLoopId = requestAnimationFrame(animationLoop);
        updateObjects();
        render();
    }

    let loopReSign = 1;
    function doLoopRe() {
        if(parameters['Loop Re']) {
            parameters['Real Part'] = parameters['Real Part'] + (loopReSign * 0.0125);
            if (parameters['Real Part'] <= 0) {
                loopReSign = 1;
                parameters['Real Part'] = 0;
            } else if (parameters['Real Part'] >= 1) {
                loopReSign = -1;
                parameters['Real Part'] = 1;
            }
            hasChanged = true;
            if ((parameters['Real Part'] * 10) % 1 === 0) {
                controllers.ctrlRe.setValue(parameters['Real Part']);
            }
        } else {
            hasChanged = false;
        }
    }

    let loopImSign = 1;
    let plotPath = [];
    let plotHasStarted = false;
    let plotHasEnded = false;
    let plotPathDrawn = false;
    function doLoopIm() {
        // adsgf;lkjasdflkasdjf;lasdfjas
        if (plotPath.length < 100) {
            plotPath.push(new THREE.Vector3(0, convergence.re, convergence.im));
        }
        if (plotPathDrawn) {
            spiralObjects.convergence.geo.dispose();
            spiralObjects.convergence.geo.setFromPoints(addSpiral(plotPath, getMaterial(20)).geoPoints);
        } else {
            spiralObjects.convergence = addSpiral(plotPath, getMaterial(20));
            group.add(spiralObjects.convergence.mesh);
            plotPathDrawn = true;
        }
        if(parameters['Loop Im']) {
            parameters['Imaginary Part'] = parameters['Imaginary Part'] + (loopImSign * (0.005 * parameters['Loop Im Speed']));
            if (parameters['Imaginary Part'] <= 0) {
                loopImSign = 1;
                parameters['Imaginary Part'] = 0;
                plotHasStarted = true;
                console.log('plot has started');
            } else if (parameters['Imaginary Part'] >= 100) {
                loopImSign = -1;
                parameters['Imaginary Part'] = 100;
                if (plotHasStarted) {
                    plotHasEnded = true;
                    console.log('plot has ended');
                }
            }
            hasChanged = true;
            if ((parameters['Imaginary Part'] * 10) % 1 === 0) {
                controllers.ctrlIm.setValue(parameters['Imaginary Part']);
            }
        } else {
            plotPath = [];
            hasChanged = false;
        }
    }

    function popGui(parameters) {
        const gui = new dat.GUI({ name: 'My GUI', load: parameters, autoPlace: true, hideable: true, closed: false, closeOnTop: true });
        controllers.ctrlLoopRe = gui.add(parameters, 'Loop Re', false, true).onFinishChange(() => {
            doLoopRe();
        });
        controllers.ctrlLoopIm = gui.add(parameters, 'Loop Im', false, true).onFinishChange(() => {
            controllers.ctrlIm.setValue(99);
            doLoopIm();
        });
        controllers.ctrlLoopImSpeed = gui.add(parameters, 'Loop Im Speed', 1, 20).onFinishChange(() => {
        });
        controllers.ctrlScale = gui.add(parameters, 'Scale', 1, 10, 1).onFinishChange(() => {
            group.scale.set(parameters['Scale'], parameters['Scale'], parameters['Scale']);
            hasChanged = true;
        });
        controllers.ctrlRe = gui.add(parameters, 'Real Part', 0.0, 1.0).onFinishChange(() => {
            hasChanged = true;
        });
        controllers.ctrlIm = gui.add(parameters, 'Imaginary Part', 0.000, 99.9999).onFinishChange(() => {
            hasChanged = true;
        });
        controllers.ctrlZero = gui.add(parameters, 'Riemann Zero #', 0, Z.length, 1).onFinishChange(() => {
            controllers.ctrlRe.setValue(0.5);
            console.log('parameters[\'Riemann Zero #\']', parameters['Riemann Zero #']);
            controllers.ctrlIm.setValue(Z[parameters['Riemann Zero #']]);
            hasChanged = true;
        });
        controllers.ctrlSmoothing = gui.add(parameters, 'Smoothing Factor', 1, 5).onFinishChange(() => {
            hasChanged = true;
        });
        controllers.ctrlDrawSum = gui.add(parameters, 'Draw Sum', false, true).onFinishChange(() => {
            hasChanged = true;
        });
    }

    const controllers = {
        ctrlLoopRe: null,
        ctrlLoopIm: null,
        ctrlScale: null,
        ctrlRe: null,
        ctrlIm: null,
        ctrlZero: null,
        ctrlSmoothing: null,
        ctrlDrawSum: null,
    };

    const parameters = {
        'Scale': 5,
        'Real Part': 0.5,
        'Imaginary Part': Z[0],
        'Riemann Zero #': 0,
        'Smoothing Factor': 1,
        'Draw Even': true,
        'Draw Odd': true,
        'Draw Sum': true,
        'Loop Re': false,
        'Loop Im': false,
        'Loop Im Speed': 20,
    };
    let hasChanged = false;
    let sumDrawn = false;
    let convergence = {
        z: 0,
        re: 0,
        im: 0
    };

    // loopRealPart(group);
    let spiralObjects = drawOneSpiral(group);
    popGui(parameters);
    animationLoop()
</script>

</body>
</html>
