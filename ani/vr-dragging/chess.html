<!DOCTYPE html>
<html lang="en">
<head>
  <title>three.js vr - dragging</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>

<script type="module">

    import { rainbow } from './modules/colors.js';
    import * as THREE from './lib/three/build/three.module.js';
    import {OrbitControls} from './lib/three/examples/jsm/controls/OrbitControls.js';
    import {VRButton} from './lib/three/examples/jsm/webxr/VRButton.js';
    import {XRControllerModelFactory} from './lib/three/examples/jsm/webxr/XRControllerModelFactory.js';

    const sceneVR = {
        camera: null,
        scene: null,
        renderer: null,
        container: null,
        controller1: null,
        controller2: null,
        controllerGrip1: null,
        controllerGrip2: null,
        controls: null,
        group: null,
        raycaster: new THREE.Raycaster(),
        intersected: [],
        tempMatrix: new THREE.Matrix4(),
        pieceRadius: 0.16,

        addRandomGeometries: function(vrScene) {
            let radius = vrScene.pieceRadius;
            let radius2x = radius * 2;
            let boardSize = 4;
            let halfBoard = boardSize / 2;
            let gap = 0.25;
            let spacing = 1 + gap;

            let geometries = [
                new THREE.CylinderBufferGeometry(radius, radius, radius, 64)
            ];

            const n = 10;
            for (let x = 0; x < n; x++) {

                let geometry = geometries[Math.floor(Math.random() * geometries.length)];
                let material = new THREE.MeshStandardMaterial({
                    color: rainbow[x * 2 + 20],
                    roughness: 0.7,
                    metalness: 0.0
                });

                let object = new THREE.Mesh(geometry, material);

                object.position.x = x * radius2x * spacing - halfBoard + radius + (0.5 * gap * radius2x);
                object.position.y = radius/2;
                object.position.z = radius - halfBoard + (0.5 * gap * radius2x);

                // object.position.x = (i % 5)/10 * 9 - 2 + 0.2;
                // object.position.y = 0.1;
                // object.position.z = (i % 2)/10 * 4.5 - 2 + 0.2;

                object.scale.setScalar(1);

                object.castShadow = true;
                object.receiveShadow = true;

                vrScene.group.add(object);
            }
        },
        addFloor: function(vrScene) {
            let geometry = new THREE.PlaneBufferGeometry(4, 4);
            let material = new THREE.MeshStandardMaterial({
                color: 0xeeeeee,
                roughness: 1.0,
                metalness: 0.0
            });
            let floor = new THREE.Mesh(geometry, material);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            vrScene.scene.add(floor);
        },
        addLight: function(vrScene) {
            vrScene.scene.add(new THREE.HemisphereLight(0x808080, 0x606060));

            let light = new THREE.DirectionalLight(0xffffff);
            light.position.set(0, 6, 0);
            light.castShadow = true;
            light.shadow.camera.top = 2;
            light.shadow.camera.bottom = -2;
            light.shadow.camera.right = 2;
            light.shadow.camera.left = -2;
            light.shadow.mapSize.set(4096, 4096);
            vrScene.scene.add(light);
        },
        addControllers: function(vrScene) {
            vrScene.controller1 = vrScene.renderer.xr.getController(0);
            vrScene.controller1.addEventListener('selectstart', vrScene.onSelectStart.bind(vrScene));
            vrScene.controller1.addEventListener('selectend', vrScene.onSelectEnd.bind(vrScene));
            vrScene.scene.add(vrScene.controller1);

            vrScene.controller2 = vrScene.renderer.xr.getController(1);
            vrScene.controller2.addEventListener('selectstart', vrScene.onSelectStart.bind(vrScene));
            vrScene.controller2.addEventListener('selectend', vrScene.onSelectEnd.bind(vrScene));
            vrScene.scene.add(vrScene.controller2);

            let controllerModelFactory = new XRControllerModelFactory();

            vrScene.controllerGrip1 = vrScene.renderer.xr.getControllerGrip(0);
            vrScene.controllerGrip1.add(controllerModelFactory.createControllerModel(vrScene.controllerGrip1));
            vrScene.scene.add(vrScene.controllerGrip1);

            vrScene.controllerGrip2 = vrScene.renderer.xr.getControllerGrip(1);
            vrScene.controllerGrip2.add(controllerModelFactory.createControllerModel(vrScene.controllerGrip2));
            vrScene.scene.add(vrScene.controllerGrip2);

            let lineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
            let line = new THREE.Line(lineGeometry);
            line.name = 'line';
            line.scale.z = 5;

            vrScene.controller1.add(line.clone());
            vrScene.controller2.add(line.clone());
        },
        init: function (generatorFx) {
            this.container = document.createElement('div');
            document.body.appendChild(this.container);
            this.renderer = new THREE.WebGLRenderer({antialias: true});
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.outputEncoding = THREE.sRGBEncoding;
            this.renderer.shadowMap.enabled = true;
            this.renderer.xr.enabled = true;
            this.container.appendChild(this.renderer.domElement);
            document.body.appendChild(VRButton.createButton(this.renderer));

            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x809090);

            this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
            this.camera.position.set(0, 1.6, 3);

            this.controls = new OrbitControls(this.camera, this.container);
            this.controls.target.set(0, 1.6, 0);
            this.controls.update();

            this.group = new THREE.Group();
            this.scene.add(this.group);

            this.addFloor(this);
            this.addLight(this);
            this.addControllers(this);

            generatorFx(this);

            window.addEventListener('resize', this.onWindowResize, false);
        },

        onWindowResize: function () {
            if (this.camera) {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        },

        onSelectStart: function (event) {
            let controller = event.target;
            let intersections = this.getIntersections(controller);

            if (intersections.length > 0) {
                let intersection = intersections[0];
                let object = intersection.object;
                object.material.emissive.b = 1;
                controller.attach(object);
                controller.userData.selected = object;
            }
        },

        onSelectEnd: function (event) {
            let controller = event.target;

            if (controller.userData.selected !== undefined) {
                let object = controller.userData.selected;
                object.material.emissive.b = 0;
                this.group.attach(object);
                object.rotation.x = 0;
                object.rotation.y = 0;
                object.rotation.z = 0;

                object.position.y = this.pieceRadius/2;
                controller.userData.selected = undefined;
            }
        },

        getIntersections: function (controller) {
            this.tempMatrix.identity().extractRotation(controller.matrixWorld);

            this.raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.tempMatrix);

            return this.raycaster.intersectObjects(this.group.children);
        },

        intersectObjects: function (controller) {
            // Do not highlight when already selected
            if (controller.userData.selected !== undefined) return;

            let line = controller.getObjectByName('line');
            let intersections = this.getIntersections(controller);

            if (intersections.length > 0) {
                let intersection = intersections[0];
                let object = intersection.object;
                object.material.emissive.r = 1;
                this.intersected.push(object);

                line.scale.z = intersection.distance;
            } else {
                line.scale.z = 5;
            }
        },

        cleanIntersected: function () {
            while (this.intersected.length) {
                let object = this.intersected.pop();
                object.material.emissive.r = 0;
            }
        },

        animate: function () {
            this.renderer.setAnimationLoop(this.render.bind(this));
        },

        render: function () {
            this.cleanIntersected();
            this.intersectObjects(this.controller1);
            this.intersectObjects(this.controller2);
            this.renderer.render(this.scene, this.camera);
        }
    };

    sceneVR.init(sceneVR.addRandomGeometries);
    sceneVR.animate();

</script>
</body>
</html>
